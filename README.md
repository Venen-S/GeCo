# GeCo
ТЗ

Задание для удобства https://drive.google.com/file/d/1pzDTYXCwnY5tha40glXjiYDX0tIFJ7S-/view?usp=sharing

Проект разбит на 4 проекта внутри решения:
1. Модели
2. Миграции и контекст
3. Логика
4. Центральный Asp.net Core WebApi проект

Для запуска проект нужно в appsettings.Development в ContextConnection ввести свою строку подключения к БД, апнуть бд и в таблице choice для каждой системы (uber и тд. в поле значения ввести название методов обработчиков) после чего можно смело запускать проект.

Для Удобства:

(Важно! значения для всех обработчиков должны строго совпадать с именами методов обработчиков, иначе не будет произведена обработка, рекомендую просто скопировать ключи/значения и приведенных ниже)

Столбец key/ Столбец value

talabat/TalabatHandlerMethod

zomato/ZomatoHandlerMethod

uber/UberHandlerMethod

В решении в качестве СУБД использовал PostgreSQL, все миграции в проекте присутствуют и адаптированы под Postgres.
В классе ApiContext проекта Data в OnModelCreating присутсвуют аннотации через FluentAPI.
Чтобы обратиться в контроллере к методу нужно сделать запрос по URL https://localhost:44388/n где n - это остальная часть Urla указанный в тз в зависимости от типа системы.
Далее в этом контроллере произойдет первоначальная обработка запроса с сохранением в бд части данных, и созданием записи в таблице process о новом поступившем заказе с хранением id из таблицы order.
Все это дело сохраняется и метод контроллера прекращает свою работу.

Далее вся работа передаеться планировщику который срабатывает каждые 5 секунд (я использовал Coravel), запускает задачу и чекает все новые заказы и в зависимости от системы начинает обрабатывать заказ.
Задача планировщика находится в классе SchedulerCoravel (неожиданно), в бд имеется 3я таблица choice которая хранит в себе подобие словаря с ключом (система) и значением (см. выше)
Так что необходимо заполнить ее, таким образом проиходит ветвление без использования условных операторов. Более целесообразно было бы не создавать дополнительную таблицу в БД и вынести
эти данные в конфиг с ключом и значением, после чего вытягивать от туда данные и в зависимости от данных выполнять ту или иную обработку, я это понимаю, но решил вынести это в БД в рамках ТЗ.

В зависимости от конкретной системы выполняется своя задача в классе Process проекта Applicationя.
После чего как по требованию тз обновляется в бд запись с заполнением в колонке converted_order с обновленным json заказа.
При возникновении ошибки происходит гарантированный запуск асинхронного метода в новом потоке с обработкой ошибки и занесением ошибки в лог файл текстовый (файл создастся автоматически) и задержкой в 10 сек, а управление внутри foreach передаеться новой итерации,
тем самым выполняя последнюю часть задачи.

В проекте достаточно все просто, мешанины нет, присутствуют комментарии обьясняющие выполнение кода пошагово, проблем с пониманием и разбором быть не должно.
